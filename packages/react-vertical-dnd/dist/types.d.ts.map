{"mappings":";AAcA,wBAAwB;IACvB,KAAK,EAAE,MAAM,aAAa,CAAC;IAC3B,WAAW,EAAE,CAAC,KAAK,EAAE,MAAM,SAAS,CAAC,WAAW,CAAC,KAAK,IAAI,CAAC;IAC3D,SAAS,EAAE,MAAM,CAAC;IAClB,GAAG,EAAE,MAAM,WAAW,CAAC,WAAW,CAAC,CAAC;CACpC,CAAC;AAEF;IACC,EAAE,EAAE,MAAM,CAAC;CACX;AAaD,sBAAsB,CAAC,SAAS,iBAAiB,IAAI;IACpD,KAAK,EAAE,CAAC,EAAE,CAAC;IACX,MAAM,EAAE,CAAC,CAAC,IAAI,EAAE,SAAS,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,SAAS,EAAE,cAAc,EAAE,OAAO,CAAC,EAAE,KAAK,MAAM,YAAY,CAAC;IAC1G,SAAS,EAAE,CAAC,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,KAAK,GAAG,CAAC;IACvD,WAAW,CAAC,EAAE,CAAC,IAAI,EAAE,iBAAiB,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC,WAAW,CAAC,KAAK,GAAG,CAAC;CACpF,CAAC;AAMF,OAAO,MAAM,yBAA0B,GAAG,EAAE,QAAQ,MAAM,MAAM,MAAM,UAKrE,CAAC;AAEF,QAAA,MAAM,WAAW,qKA2LhB,CAAC;AACF,eAAe,WAAW,CAAC","sources":["packages/react-vertical-dnd/src/src/reactDragAndDrop.tsx","packages/react-vertical-dnd/src/reactDragAndDrop.tsx"],"sourcesContent":[null,"// Features I want:\n// + Basic drag and drop\n// + HTML5 dnd\n// + A drag finished callback\n// - The ability to cancel a drag\n// + Axis lock\n// + Lock to the parent component\n// Ideally:\n//\t- Drag and drop between components (Seems difficult...)\n//  + The ability to handle items of multiple sizes\n//  + The ability to handle list mutations (items added, items removed)\nimport React, { useCallback, useEffect, useRef, useState } from \"react\";\n\nconst DRAG_SPEED = 150; //translation transform time in ms\nexport type DragProps = {\n\tstyle: React.CSSProperties;\n\tonDragStart: (event: React.DragEvent<HTMLElement>) => void;\n\tdraggable: \"true\";\n\tref: React.RefCallback<HTMLElement>;\n};\n\ninterface RearrangeableItem {\n\tid: string;\n}\n\ntype ActiveDragInfo = {\n\tid: string;\n\tstartingIndex: number; // The index of the element when the drag started\n\tmouseElementOffset: number; // The offset between element ypos and mouse\n\trestingPosition: number; // The planned position of the element when the drag ends\n\tlastMousePosition: number;\n\trestingPositionItemId: string; // The id of element currently displaced by dragged element\n\tinitialElementBounds: { [id: string]: [yPosition: number, height: number] }; // The bounds of each element when the drag started. Height includes gap\n\tbottomPosition: number; // The lowest possible position of the current dragged element\n};\n\ntype DragAndDropProps<T extends RearrangeableItem> = {\n\titems: T[];\n\trender: ([item, dragProps]: [item: T, props: DragProps, itemIsDragging: boolean][]) => React.ReactElement;\n\tonDragEnd: (fromIndex: number, toIndex: number) => any;\n\tonDragStart?: (item: RearrangeableItem, event: React.DragEvent<HTMLElement>) => any;\n};\n\nfunction getElementYPosition(element: HTMLElement): number {\n\treturn element.getBoundingClientRect().top + window.scrollY;\n}\n\nexport const arrWithReposition = (arr: any[], from: number, to: number) => {\n\tconst result = [...arr];\n\tconst [removed] = result.splice(from, 1);\n\tresult.splice(to, 0, removed);\n\treturn result;\n};\n\nconst DragAndDrop = <T extends RearrangeableItem>({ render, items, onDragEnd, onDragStart }: DragAndDropProps<T>) => {\n\tconst [draggingInfo, setDraggingInfo] = useState<ActiveDragInfo | null>(null);\n\tconst [dragElements, setDragElements] = useState<{ [id: string]: HTMLElement }>({});\n\tconst [elementTranslations, setElementTranslations] = useState<{ [id: string]: number }>({});\n\tconst [DIFT, setDIFT] = useState<{\n\t\tid: string;\n\t\ttimeout: number;\n\t\telement: HTMLElement;\n\t\tnewTranslateY: number;\n\t} | null>(null); // set while dragged item transitions to it's final position using CSS.\n\n\tconst recalculateDraggingInfo = (draggingItemId: string, mouseElementOffset: number) => {\n\t\tconst getElementInitYFromIndex = (index: number) => {\n\t\t\tconst element = dragElements[items[index].id];\n\t\t\tconst translation = elementTranslations[items[index].id] || 0;\n\t\t\treturn getElementYPosition(element) - translation;\n\t\t};\n\t\tconst getElementHeightFromIndex = (index: number) => {\n\t\t\tconst element = dragElements[items[index].id];\n\t\t\treturn element.getBoundingClientRect().height;\n\t\t};\n\n\t\tconst elementIndex = items.findIndex(item => item.id === draggingItemId);\n\t\tconst startingPosition = getElementInitYFromIndex(elementIndex);\n\t\tconst startingIndex = items.map(({ id }) => id).indexOf(draggingItemId);\n\n\t\tconst gap = getElementInitYFromIndex(1) - (getElementInitYFromIndex(0) + getElementHeightFromIndex(0));\n\n\t\tconst initialElementBounds = Object.fromEntries(\n\t\t\titems.map(({ id }, index) => [\n\t\t\t\tid,\n\t\t\t\t[getElementInitYFromIndex(index), getElementHeightFromIndex(index) + gap] as [number, number],\n\t\t\t])\n\t\t);\n\t\tgetElementInitYFromIndex(items.length - 1) + getElementHeightFromIndex(items.length - 1) + gap;\n\n\t\tsetDraggingInfo({\n\t\t\tid: draggingItemId,\n\t\t\tmouseElementOffset,\n\t\t\tstartingIndex,\n\t\t\trestingPositionItemId: draggingItemId,\n\t\t\tlastMousePosition: startingPosition + mouseElementOffset,\n\t\t\trestingPosition: startingPosition,\n\t\t\tinitialElementBounds,\n\t\t\tbottomPosition:\n\t\t\t\tgetElementInitYFromIndex(items.length - 1) +\n\t\t\t\tgetElementHeightFromIndex(items.length - 1) -\n\t\t\t\tgetElementHeightFromIndex(elementIndex),\n\t\t\t// gap,\n\t\t});\n\t\t// handleNewMousePosition(initialMousePosition);\n\t};\n\tconst dragBeginning = (event: React.DragEvent<HTMLElement>, item: RearrangeableItem) => {\n\t\tevent.dataTransfer.setDragImage(document.createElement(\"div\"), 0, 0);\n\t\tif (items.length < 2) return;\n\t\tif (onDragStart) onDragStart(item, event);\n\t\tif (DIFT) {\n\t\t\tclearTimeout(DIFT.timeout);\n\t\t\tsetDIFT(null);\n\t\t}\n\t\trecalculateDraggingInfo(item.id, event.pageY - getElementYPosition(dragElements[item.id]));\n\t};\n\n\tconst handleNewMousePosition = (newMousePostion: number) => {\n\t\tif (!draggingInfo) return;\n\t\tif (newMousePostion == draggingInfo.lastMousePosition) return;\n\t\tlet dragInfoToSet = { ...draggingInfo, lastMousePosition: newMousePostion };\n\t\tconst elementPosition = newMousePostion - draggingInfo.mouseElementOffset;\n\t\tconst [closestPositionItemId] = Object.entries(draggingInfo.initialElementBounds).reduce(\n\t\t\t(closest, [currentId, [currentPosition]]) => {\n\t\t\t\tconst distance = Math.abs(elementPosition - currentPosition);\n\t\t\t\treturn distance < closest[1] ? [currentId, distance] : closest;\n\t\t\t},\n\t\t\t[\"\", Infinity]\n\t\t);\n\t\tlet newElementTranslations = { ...elementTranslations }; // a new object must be created so as to trigger the rerender\n\t\tif (draggingInfo.restingPositionItemId != closestPositionItemId) {\n\t\t\tnewElementTranslations = {};\n\t\t\tconst [restingPosition] = draggingInfo.initialElementBounds[closestPositionItemId];\n\t\t\tdragInfoToSet = { ...dragInfoToSet, restingPositionItemId: closestPositionItemId, restingPosition };\n\t\t\tconst restingPositionIndex = items.findIndex(({ id }) => id === closestPositionItemId);\n\t\t\tconst intermediateItems =\n\t\t\t\trestingPositionIndex > draggingInfo.startingIndex\n\t\t\t\t\t? items.slice(draggingInfo.startingIndex + 1, restingPositionIndex + 1)\n\t\t\t\t\t: items.slice(restingPositionIndex, draggingInfo.startingIndex);\n\t\t\tconst down = restingPositionIndex > draggingInfo.startingIndex;\n\t\t\tintermediateItems.forEach(item => {\n\t\t\t\tnewElementTranslations[item.id] = (down ? -1 : 1) * draggingInfo.initialElementBounds[draggingInfo.id][1];\n\t\t\t});\n\t\t}\n\t\t//axis lock\n\t\tconst top = draggingInfo.initialElementBounds[items[0].id][0];\n\t\tconst bottom = draggingInfo.bottomPosition;\n\n\t\tconst newElementPosition = Math.min(Math.max(elementPosition, top), bottom);\n\t\tnewElementTranslations[draggingInfo.id] =\n\t\t\tnewElementPosition - draggingInfo.initialElementBounds[draggingInfo.id][0];\n\t\t//\n\t\tsetElementTranslations(newElementTranslations);\n\t\tsetDraggingInfo(dragInfoToSet);\n\t};\n\tconst dragEnding = () => {\n\t\tif (!draggingInfo) return;\n\t\tconst element = dragElements[draggingInfo.id];\n\t\tconst [previousTenetY, previousTenetHeight] = draggingInfo.initialElementBounds[draggingInfo.restingPositionItemId];\n\t\tconst newPosition =\n\t\t\telementTranslations[draggingInfo.id] < 0\n\t\t\t\t? previousTenetY\n\t\t\t\t: previousTenetY + previousTenetHeight - draggingInfo.initialElementBounds[draggingInfo.id][1];\n\t\tconst newTranslateY = getElementYPosition(element) - newPosition;\n\t\tsetDIFT({\n\t\t\tid: draggingInfo.id,\n\t\t\ttimeout: setTimeout(() => {\n\t\t\t\tsetDIFT(null);\n\t\t\t\telement.style.transition = \"\";\n\t\t\t}, DRAG_SPEED),\n\t\t\telement,\n\t\t\tnewTranslateY,\n\t\t});\n\t\tsetDraggingInfo(null);\n\t\tonDragEnd(\n\t\t\tdraggingInfo.startingIndex,\n\t\t\titems.findIndex(({ id }) => id === draggingInfo.restingPositionItemId)\n\t\t);\n\t\tsetElementTranslations({});\n\t};\n\n\tconst handleNewMousePositionRef = useRef(handleNewMousePosition);\n\thandleNewMousePositionRef.current = handleNewMousePosition;\n\tconst dragEndingRef = useRef(dragEnding);\n\tdragEndingRef.current = dragEnding;\n\n\tuseEffect(() => {\n\t\tconst handleDragMoving = (event: MouseEvent) => {\n\t\t\tevent.preventDefault(); // Allows drop to occur instantly, rather than after a 0.5s delay (for some reason)\n\t\t\thandleNewMousePositionRef.current(event.pageY);\n\t\t};\n\t\tconst handleDragEnd = () => dragEndingRef.current();\n\t\tdocument.addEventListener(\"dragover\", handleDragMoving);\n\t\tdocument.addEventListener(\"dragend\", handleDragEnd);\n\t\treturn () => {\n\t\t\tdocument.removeEventListener(\"dragover\", handleDragMoving);\n\t\t\tdocument.removeEventListener(\"dragend\", handleDragEnd);\n\t\t};\n\t}, []);\n\n\tuseEffect(() => {\n\t\tconst itemIds = items.map(item => item.id);\n\t\tconst newDragElements: { [id: string]: HTMLElement } = {};\n\t\tObject.keys(dragElements).forEach(id => {\n\t\t\tif (id in itemIds) newDragElements[id] = dragElements[id];\n\t\t});\n\t\tsetDragElements(newDragElements);\n\t\tif (DIFT) {\n\t\t\tconst { id, element, newTranslateY } = DIFT;\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\telement.style.transform = `translateY(${newTranslateY}px)`;\n\t\t\t\telement.style.transition = \"transform 0s\";\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\telement.style.transform = \"\";\n\t\t\t\t\telement.style.transition = `transform ${DRAG_SPEED}ms`;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tif (draggingInfo) recalculateDraggingInfo(draggingInfo?.id, draggingInfo?.mouseElementOffset);\n\t}, [items]);\n\n\tconst renderParameter = items.map((item: T): [T, DragProps, boolean] => {\n\t\tlet itemStyle: { [styleName: string]: string } = {};\n\t\tconst elementIsDragging = draggingInfo?.id === item.id;\n\t\tif (draggingInfo && !elementIsDragging) itemStyle[\"transition\"] = `transform ${DRAG_SPEED}ms`;\n\t\tif (item.id in elementTranslations) itemStyle[\"transform\"] = `translateY(${elementTranslations[item.id]}px)`;\n\n\t\treturn [\n\t\t\titem,\n\t\t\t{\n\t\t\t\tstyle: itemStyle,\n\t\t\t\tonDragStart: (event: React.DragEvent<HTMLElement>) => dragBeginning(event, item),\n\t\t\t\tdraggable: \"true\",\n\t\t\t\tref: (instance: HTMLElement | null) => {\n\t\t\t\t\tdragElements[item.id] = instance!;\n\t\t\t\t},\n\t\t\t},\n\t\t\telementIsDragging,\n\t\t];\n\t});\n\treturn render(renderParameter);\n};\nexport default DragAndDrop;\n"],"names":[],"version":3,"file":"types.d.ts.map"}